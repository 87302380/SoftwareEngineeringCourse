# Software engineering from 10.000ft
## Software engineering is an unpredictable process
- often-cited comparison: building architecture => not really good comparison
- complex, not just complicated
- developing software more like science instead of producing / building something: You never know what will be the result and when it will be there => "building" is so fast nowadays, a lot of programmers don't even notice it ("build"-step)
- uncertainty theory of software development: either know __when__ a software releases or __what__ it will do (never both)
- one cause of unpredictability: human factor ("Es menschelt") - no model can eliminate that, except for Cyberdyne Systems

## Building blocks of software engineering
- programming languages
    - web-ish:
        - Java Script - family (everything ending with "JS")
    - OOP:
        - Java extremely interesting because of distribution, active community and evolution of the language itself
        - C#, C++
    - mobile
        - Swift
    - hardware
        - Assembler
        - C
- community, conferences, Hackatons, user groups, ...
    - Do yourself a favor and have a look at hacktalk and JUG Ostfalen! 
- models
    - Domain Driven Design
- best practices
    - TDD
- tools
    - IDEs
    - version control
    - building tools
    - analysis
- processes
    - waterfall
    - agile (Scrum, Kanban)
    - project management
- soft skills - Do yourself a favor and develop them! 

## Software engineering can be handled
- over the decades a ton of methods, processes and models
- working, but dependent on circumstances
- because of relatively young branch emerging new concepts

## Opportunities
- because of all this: highly dynamic, omnipresent key-branch with huge opportunities
- favorite examples: 
    - Apple: "Let's sell the people the music they want to hear instead of hunting the leechers"
    - Tesla: "Let's think of a car as a moving computer!"
    - remote working movement
    - "thinking IT"